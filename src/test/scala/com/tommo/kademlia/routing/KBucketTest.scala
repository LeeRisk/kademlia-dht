package com.tommo.kademlia.routing

import com.tommo.kademlia.BaseUnitTest

import com.tommo.kademlia.misc.time.Clock
import com.tommo.kademlia.protocol._
import com.tommo.kademlia.identity._

class KBucketTest extends BaseUnitTest with BaseKBucketFixture {

  import java.util.UUID.randomUUID

  def withRandomNodes(numNodes: Int) = for (i <- List.range(0, numNodes)) yield (RemoteNode(mockHost, aRandomId))

  def aRandomNode = withRandomNodes(1).head

  def prefillKBucket(capacity: Int = 10, numNodes: Int = 9) = {
    if (capacity < numNodes) throw new IllegalArgumentException(s"Can't prefill kbucket with $numNodes of capacity $capacity")

    val kbucket = withCapacity[RemoteNode](capacity)
    val nodes = withRandomNodes(numNodes)
    nodes.foreach(kbucket.add(_))
    (kbucket, nodes)
  }

  test("add a new node if the capacity is not full") {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 0)

    val newNode = aRandomNode
    kbucket.add(newNode)

    kbucket.getNodes should contain theSameElementsAs List(newNode)
  }

  test("replace an existing node when adding") {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 0)

    val newNode = aRandomNode
    kbucket.add(newNode)
    kbucket.add(newNode)

    kbucket.getNodes should contain theSameElementsAs List(newNode)
  }
  
  test("don't add a new node if current size exceeds capacity") {
    val (kbucket, nodeList) = prefillKBucket(capacity = 2, numNodes = 2)

    kbucket.add(aRandomNode)
    kbucket.getNodes should contain theSameElementsAs nodeList
  }

  test("correctly reflect the current nodes occupied") {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 2)
    assert(kbucket.size == 2)
  }

  test("be able to remove a node") {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 0)
    val newNode = aRandomNode
    kbucket.add(newNode)
    kbucket.remove(newNode)

    kbucket.getNodes should contain theSameElementsAs List()
  }

  test("return the minimum ordering as defined by ordering") {
    val (kbucket, nodeList) = prefillKBucket(capacity = 2, numNodes = 2)
    assert(kbucket.getLowestOrder == nodeList.head)
  }

  test("use the time generated by Clock") {
    var currentCount = 0

    trait StubbedClock extends Clock {
      override def getTime() = { currentCount += 1; currentCount }
    }

    val kbucket = new KBucket[RemoteNode](2)(LastSeenOrdering()) with StubbedClock { type T = RemoteNode }

    kbucket.add(aRandomNode)

    assert(currentCount == 1)
  }

}
package com.tommo.kademlia.routing

import com.tommo.kademlia.BaseUnitTest

import com.tommo.kademlia.misc.time.Clock
import com.tommo.kademlia.protocol._
import com.tommo.kademlia.identity._

class KBucketTest extends BaseUnitTest  {

  trait Fixture extends BaseKBucketFixture {
    import java.util.UUID.randomUUID
    
    def withRandomNodes(numNodes: Int) = for (i <- List.range(0, numNodes)) yield (RemoteNode(mockHost, aRandomId))
    
    def aRandomNode = withRandomNodes(1).head

    def prefillKBucket(capacity: Int = 10, numNodes: Int = 9) = {
      if (capacity < numNodes) throw new IllegalArgumentException(s"Can't prefill kbucket with $numNodes of capacity $capacity")

      val kbucket = withCapacity[RemoteNode](capacity)
      val nodes = withRandomNodes(numNodes)
      nodes.foreach(kbucket.add(_))
      (kbucket, nodes)
    }
  }

  "KBucket" should "add a new node if the capacity is not full" in new Fixture {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 0)

    val newNode = aRandomNode
    kbucket.add(newNode)

    kbucket.getNodes should contain theSameElementsAs List(newNode)
  }

  it should "replace an existing node when adding" in new Fixture {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 0)

    val newNode = aRandomNode
    kbucket.add(newNode)
    kbucket.add(newNode)

    kbucket.getNodes should contain theSameElementsAs List(newNode)
  }

  it should "not add a new if current size exceeds capacity" in new Fixture {
    val (kbucket, nodeList) = prefillKBucket(capacity = 2, numNodes = 2)

    kbucket.add(aRandomNode)
    kbucket.getNodes should contain theSameElementsAs nodeList
  }

  it should "correctly reflect the current nodes occupied" in new Fixture {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 2)
    assert(kbucket.size == 2)
  }

  it should "be able to remove a node" in new Fixture {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 0)
    val newNode = aRandomNode
    kbucket.add(newNode)
    kbucket.remove(newNode)

    kbucket.getNodes should contain theSameElementsAs List()
  }

  it should "return the minimum ordering as defined by ordering" in new Fixture {
    val (kbucket, nodeList) = prefillKBucket(capacity = 2, numNodes = 2)
    assert(kbucket.getLowestOrder == nodeList.head)
  }
  
  it should "use the time generated by Clock" in new Fixture { 
    var currentCount = 0

    trait StubbedClock extends Clock {
      def getTime() = { currentCount += 1; currentCount }
    }
    
    val kbucket = new KBucket[RemoteNode](2)(LastSeenOrdering()) with StubbedClock { type T = RemoteNode }
    
    kbucket.add(aRandomNode)
    
    assert(currentCount == 1)
  }
  

}
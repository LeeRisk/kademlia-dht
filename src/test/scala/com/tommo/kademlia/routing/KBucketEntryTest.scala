package com.tommo.kademlia.routing

import com.tommo.kademlia.BaseUnitTest

import com.tommo.kademlia.misc.time.Clock
import com.tommo.kademlia.protocol._
import com.tommo.kademlia.identity._

class KBucketEntryTest extends BaseUnitTest {

  trait Fixture {
    trait IncrementingClock extends Clock {
      var counter = 0
      def getTime() = { counter += 1; counter }
    }

    def withCapacity(capacity: Int) = new KBucketEntry(capacity)(LastSeenOrdering()) with IncrementingClock

    import java.util.UUID.randomUUID

    def withRandomNodes(numNodes: Int) = for (i <- List.range(0, numNodes)) yield (Node(Host("hostname:9009"), Id(randomUUID.toString.getBytes())))

    def aRandomNode = withRandomNodes(1).head

    def prefillKBucket(capacity: Int = 10, numNodes: Int = 9) = {
      if (capacity < numNodes) throw new IllegalArgumentException(s"Can't prefill kbucket with $numNodes of capacity $capacity")

      val kbucket = withCapacity(capacity)
      val nodes = withRandomNodes(numNodes)
      nodes.foreach(kbucket.add(_))
      (kbucket, nodes)
    }
  }

  "A KBucketEntry" should "add a new node if the capacity is not full" in new Fixture {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 0)

    val newNode = aRandomNode
    kbucket.add(newNode)

    kbucket.getNodes should contain theSameElementsAs List(newNode)
  }

  it should "replace an existing node when adding" in new Fixture {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 0)

    val newNode = aRandomNode
    kbucket.add(newNode)
    kbucket.add(newNode)

    kbucket.getNodes should contain theSameElementsAs List(newNode)
  }

  it should "not add a new if current size exceeds capacity" in new Fixture {
    val (kbucket, nodeList) = prefillKBucket(capacity = 2, numNodes = 2)

    kbucket.add(aRandomNode)
    kbucket.getNodes should contain theSameElementsAs nodeList
  }

  it should "correctly reflect the current nodes occupied" in new Fixture {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 2)
    assert(kbucket.size == 2)
  }

  it should "be able to remove a node" in new Fixture {
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 0)
    val newNode = aRandomNode
    kbucket.add(newNode)
    kbucket.remove(newNode)

    kbucket.getNodes should contain theSameElementsAs List()
  }

  it should "return the maximum ordering as defined by ordering" in new Fixture {
    val (kbucket, nodeList) = prefillKBucket(capacity = 2, numNodes = 2)
    assert(kbucket.getHighestOrder == nodeList.tail.head)
  }

  it should "return the minimum ordering as defined by ordering" in new Fixture {
    val (kbucket, nodeList) = prefillKBucket(capacity = 2, numNodes = 2)
    assert(kbucket.getLowestOrder == nodeList.head)
  }
  
  it should "use the time generated by Clock" in new Fixture { 
    val (kbucket, _) = prefillKBucket(capacity = 2, numNodes = 0)
  }
  

}